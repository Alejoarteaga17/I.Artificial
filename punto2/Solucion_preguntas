
1. ¿Cómo cambia el comportamiento del algoritmo si cambiamos la función de costo?

 R/= Si usamos un costo mayor para ciertas celdas, el robot evitará esas zonas si encuentra caminos más baratos, aunque sean más largos.
Si la función de costo ya no representa bien el costo real del camino (asignar valores negativos o irreales), A* puede dejar de encontrar el camino óptimo, o incluso no encontrar ninguno.

2.  ¿Qué sucede si hay múltiples salidas en el laberinto? ¿Cómo podrías modificar el algoritmo para manejar esto? Plantea una propuesta.

 R/= Si hay múltiples salidas, por ejemplo, varias ‘E’,en el laberinto y el algoritmo sigue buscando una posición específica, sólo encontrará la que coincida exactamente con la coordenada end.

Propuesta para solucionarlo:
- Paso 1: Buscar todas las coordenadas que contienen ‘E’ y guardarlas en una lista:

goals = [(i, j) for i in range(len(maze)) for j in range(len(maze[0])) if maze[i][j] == 'E']

- Paso 2: Durante la búsqueda, verificar si el nodo actual está en esa lista de salidas:

if node.position in goals:
    return reconstruct_path(node)

3. Modifica el laberinto por uno más grande y con otro tipo de obstáculo además de paredes. ¿Qué limitación encuentras en el algoritmo? 

 R/= Al aumentar el tamaño del laberinto y los tipos de obstáculos, pueden surgir varias limitaciones:
 
**Consumo de memoria y tiempo:**
- A* puede explorar muchos nodos si el laberinto es grande.
- Puede volverse muy lento o incluso inviable si el espacio de búsqueda es enorme.

**Obstáculos no manejados:**
- Si hay nuevos tipos de obstáculos (como trampas, zonas con alto costo, o caminos temporales), el algoritmo necesitaría saber cómo tratar cada tipo, es decir, una función de costo personalizada.

**El algoritmo no adapta estrategias inteligentes:**
- No aprende ni adapta su comportamiento. No sabrá, por ejemplo, evitar un área que siempre resulta en caminos sin salida a menos que lo "descubra" mediante la exploración completa.